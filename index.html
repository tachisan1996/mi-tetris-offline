<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Pastel</title>
    <style>
        /* Estilo personalizado para el canvas del juego */
        canvas {
            background-color: #f0f4f8; /* Un azul muy claro y suave */
            border: 4px solid #a7d9f7; /* Borde azul pastel */
            border-radius: 12px; /* Esquinas redondeadas para el canvas */
            display: block;
            margin: 0 auto;
            touch-action: none; /* MUY IMPORTANTE: Previene el desplazamiento por defecto en móviles */
        }

        /* Estilo general para el cuerpo de la página */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #e0f2f7 0%, #c8e6c9 100%); /* Degradado suave de pastel */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #4a5568; /* Color de texto suave */
        }

        /* Contenedor principal del juego */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; /* Fondo blanco para el contenedor */
            border-radius: 20px; /* Esquinas más redondeadas */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Sombra suave */
            padding: 25px;
            gap: 20px; /* Espacio entre elementos */
            position: relative; /* Para posicionar los mensajes */
        }

        /* Estilo para el mensaje de combo */
        #combo-message, #level-up-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            color: #ef4444; /* Rojo vibrante */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none; /* Permite clics a través del mensaje */
            text-align: center; /* Centra el texto */
        }

        #level-up-message {
            color: #4CAF50; /* Verde para mensajes de nivel */
            font-size: 2.5em; /* Un poco más pequeño que los combos */
        }

        #combo-message.show, #level-up-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        /* Estilo para el botón de pausa */
        .pause-button {
            background-color: #FFC107; /* Amarillo pastel */
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            transform: scale(1);
            border: none;
            cursor: pointer;
            margin-top: 10px; /* Espacio superior */
        }

        .pause-button:hover {
            background-color: #FFA000; /* Amarillo más oscuro al pasar el ratón */
            transform: scale(1.05);
        }

        .pause-button:active {
            transform: scale(0.98);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Adaptabilidad para pantallas pequeñas */
        @media (max-width: 640px) {
            .game-container {
                padding: 15px;
                gap: 15px;
            }
            #combo-message {
                font-size: 2.2em;
            }
            #level-up-message {
                font-size: 1.8em;
            }
            .pause-button {
                padding: 0.6rem 1.2rem;
                font-size: 1em;
            }
        }
    </style>
</head>
<body class="selection:bg-pink-200 selection:text-pink-800">
    <div class="game-container">
        <h1 class="text-4xl md:text-5xl font-extrabold text-blue-600 mb-4 text-center">Tetris Pastel</h1>
        <div id="game-info" class="text-lg font-semibold text-gray-700 mb-3 text-center">
            Puntuación: <span id="score">0</span> | Nivel: <span id="level">1</span> | Siguiente: <span id="next-piece-display"></span>
        </div>
        <canvas id="tetrisCanvas"></canvas>
        <div id="game-message" class="text-2xl font-bold text-red-500 hidden mt-4"></div>
        <div id="combo-message"></div> <!-- Mensaje de combo -->
        <div id="level-up-message"></div> <!-- Mensaje de subir de nivel -->

        <!-- Botón de Pausa -->
        <button id="pauseButton" class="pause-button">Pausar</button>

        <!-- Los controles táctiles ahora se implementan directamente en el canvas -->
    </div>

    <script>
        // --- Configuración del Canvas ---
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');

        const COLS = 10; // Columnas del tablero
        const ROWS = 20; // Filas del tablero
        const BLOCK_SIZE = 35; // Tamaño de cada bloque en píxeles (AUMENTADO)

        // Ajusta el tamaño del canvas
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        // --- Variables del Juego ---
        let board = []; // El tablero de juego
        let currentPiece; // La pieza actual en juego
        let nextPiece; // La siguiente pieza
        let score = 0; // Puntuación del jugador
        let gameOver = false; // Estado del juego
        let gameLoopId; // ID para el loop del juego (para clearInterval)
        let lastUpdateTime = 0; // Para controlar el tiempo de caída de la pieza

        let level = 1; // Nivel actual del juego
        let linesClearedTotal = 0; // Total de líneas limpiadas en el juego (se mantiene para estadísticas, pero el score define el nivel)
        const BASE_FALL_INTERVAL = 500; // Intervalo de caída base en ms (0.5 segundos)
        let currentFallInterval = BASE_FALL_INTERVAL; // Intervalo de caída actual
        let nextLevelScoreThreshold = 2000; // Puntos necesarios para el siguiente nivel
        let isPaused = false; // Variable para controlar el estado de pausa

        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const gameMessage = document.getElementById('game-message');
        const nextPieceDisplay = document.getElementById('next-piece-display');
        const comboMessageElement = document.getElementById('combo-message');
        const levelUpMessageElement = document.getElementById('level-up-message'); // Nuevo elemento para mensajes de nivel
        const pauseButton = document.getElementById('pauseButton');

        // --- Colores Pastel para las Piezas ---
        const COLORS = [
            '#FFD1DC', // Rosa Pastel (I)
            '#FFECB3', // Amarillo Claro Pastel (O)
            '#B2EBF2', // Azul Claro Pastel (T)
            '#C8E6C9', // Verde Menta Pastel (S)
            '#F0F4C3', // Crema Pastel (Z)
            '#B3E0FF', // Azul Cielo Pastel (J)
            '#D1C4E9'  // Lavanda Pastel (L)
        ];

        // --- Definición de Piezas (Tetrominoes) ---
        // Cada pieza es un array de matrices, representando sus rotaciones.
        // Los números indican el color/tipo de la pieza (índice en COLORS).
        const TETROMINOES = [
            // I (Recta)
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
            [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]],

            // O (Cuadrado)
            [[2, 2], [2, 2]],

            // T
            [[0, 3, 0], [3, 3, 3], [0, 0, 0]],
            [[3, 0, 0], [3, 3, 0], [3, 0, 0]],
            [[0, 0, 0], [3, 3, 3], [0, 3, 0]],
            [[0, 3, 0], [0, 3, 3], [0, 3, 0]],

            // S
            [[0, 4, 4], [4, 4, 0], [0, 0, 0]],
            [[4, 0, 0], [4, 4, 0], [0, 4, 0]],

            // Z
            [[5, 5, 0], [0, 5, 5], [0, 0, 0]],
            [[0, 5, 0], [5, 5, 0], [5, 0, 0]],

            // J
            'I': { shape: [[1, 1, 1, 1]], colorIndex: 0 },
            'O': { shape: [[1, 1], [1, 1]], colorIndex: 1 },
            'T': { shape: [[0, 1, 0], [1, 1, 1]], colorIndex: 2 },
            'S': { shape: [[0, 1, 1], [1, 1, 0]], colorIndex: 3 },
            'Z': { shape: [[1, 1, 0], [0, 1, 1]], colorIndex: 4 },
            'J': { shape: [[1, 0, 0], [1, 1, 1]], colorIndex: 5 },
            'L': { shape: [[0, 0, 1], [1, 1, 1]], colorIndex: 6 }
        };

        // Class para representar una pieza de Tetris
        class Piece {
            constructor(shapeType) {
                const { shape, colorIndex } = TETROMINO_SHAPES[shapeType];
                this.shape = shape;
                this.color = COLORS[colorIndex];
                this.x = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2); // Posición inicial X
                this.y = 0; // Posición inicial Y
                this.shapeType = shapeType; // Guarda el tipo de forma (para mostrar la siguiente)
            }

            // Dibuja la pieza en el canvas
            draw() {
                this.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value > 0) {
                            ctx.fillStyle = this.color;
                            ctx.fillRect(this.x * BLOCK_SIZE + c * BLOCK_SIZE, this.y * BLOCK_SIZE + r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            ctx.strokeStyle = '#fff'; // Borde blanco suave para los bloques
                            ctx.lineWidth = 1;
                            ctx.strokeRect(this.x * BLOCK_SIZE + c * BLOCK_SIZE, this.y * BLOCK_SIZE + r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    });
                });
            }

            // Mueve la pieza
            move(dx, dy) {
                if (!this.collision(dx, dy, this.shape)) {
                    this.x += dx;
                    this.y += dy;
                    return true;
                }
                return false;
            }

            // Rota la pieza
            rotate() {
                // Función para transponer una matriz (filas a columnas)
                const transpose = (matrix) => matrix[0].map((_, i) => matrix.map(row => row[i]));
                // Función para invertir las filas de una matriz (para rotación anti-horaria)
                const reverseRows = (matrix) => matrix.map(row => [...row].reverse());

                let rotatedShape = transpose(this.shape);
                // Si es la pieza 'I' o 'S' o 'Z', rota de forma diferente para mantener la forma
                if (this.shapeType === 'I' || this.shapeType === 'S' || this.shapeType === 'Z') {
                    rotatedShape = reverseRows(rotatedShape);
                } else {
                    rotatedShape = rotatedShape.reverse(); // Rotación normal para otras piezas
                }

                if (!this.collision(0, 0, rotatedShape)) {
                    this.shape = rotatedShape;
                    return true;
                }
                // Si la rotación causa colisión, intenta desplazar la pieza (Wall Kick)
                const kicks = [
                    [0, 0], [-1, 0], [1, 0], [0, -1], [-1, -1], [1, -1]
                ]; // Posibles desplazamientos para wall kick

                for (let i = 0; i < kicks.length; i++) {
                    const [dx, dy] = kicks[i];
                    if (!this.collision(dx, dy, rotatedShape)) {
                        this.x += dx;
                        this.y += dy;
                        this.shape = rotatedShape;
                        return true;
                    }
                }
                return false;
            }

            // Comprueba si hay colisión en una posición dada con una forma específica
            collision(dx, dy, newShape) {
                for (let r = 0; r < newShape.length; r++) {
                    for (let c = 0; c < newShape[r].length; c++) {
                        if (newShape[r][c] > 0) { // Si es un bloque de la pieza
                            let newX = this.x + c + dx;
                            let newY = this.y + r + dy;

                            // Comprueba los límites del tablero y las colisiones con bloques existentes
                            if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 'empty')) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Bloquea la pieza en el tablero
            lock() {
                this.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value > 0) {
                            let boardX = this.x + c;
                            let boardY = this.y + r;
                            if (boardY < 0) { // Si la pieza está por encima del tablero (game over)
                                gameOver = true;
                                gameMessage.textContent = '¡Game Over!';
                                gameMessage.classList.remove('hidden');
                                clearInterval(gameLoopId); // Detiene el bucle del juego
                                return;
                            }
                            board[boardY][boardX] = this.color; // Asigna el color al tablero
                        }
                    });
                });
                this.clearLines(); // Comprueba y limpia líneas
                this.generateNewPiece(); // Genera una nueva pieza
            }
            // Elimina líneas completas del tablero
            clearLines() {
                let linesCleared = 0;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r].every(cell => cell !== 'empty')) { // Si la fila está completa
                        linesCleared++;
                        // Elimina la fila y añade una nueva fila vacía al principio
                        board.splice(r, 1);
                        board.unshift(Array(COLS).fill('empty'));
                        r++; // Vuelve a verificar la misma fila (ahora con los bloques de arriba)
                    }
                }
                if (linesCleared > 0) {
                    score += linesCleared * 100 * level; // Aumenta la puntuación, influenciada por el nivel
                    scoreDisplay.textContent = score;

                    linesClearedTotal += linesCleared; // Actualiza el total de líneas limpiadas

                    // Verifica si se sube de nivel basado en la puntuación
                    if (level < 10 && score >= nextLevelScoreThreshold) { // Máximo 10 niveles
                        level++;
                        levelDisplay.textContent = level;
                        // Recalcula el umbral de puntos para el siguiente nivel
                        // Nivel 1 a 2: 2000, Nivel 2 a 3: 3000, Nivel 3 a 4: 4000, etc.
                        nextLevelScoreThreshold = 2000 + (level - 1) * 1000;

                        // Reduce el intervalo de caída para aumentar la velocidad (dificultad)
                        currentFallInterval = Math.max(50, BASE_FALL_INTERVAL - (level * 50));
                        displayLevelUpMessage(); // Muestra el mensaje de nivel
                    }

                    // Efectos especiales para combos
                    if (linesCleared === 2) {
                        displayComboMessage('¡Doble!');
                    } else if (linesCleared === 3) {
                        displayComboMessage('¡Triple!');
                    } else if (linesCleared === 4) {
                        displayComboMessage('¡Tetris!');
                    }
                }
            }

            // Genera una nueva pieza para el juego
            generateNewPiece() {
                currentPiece = nextPiece;
                nextPiece = this.randomPiece();
                this.drawNextPiece();
                if (currentPiece.collision(0, 0, currentPiece.shape)) { // Si la nueva pieza colisiona al inicio
                    gameOver = true;
                    gameMessage.textContent = '¡Game Over!';
                    gameMessage.classList.remove('hidden');
                    clearInterval(gameLoopId);
                }
            }

            // Devuelve una pieza aleatoria
            randomPiece() {
                const types = Object.keys(TETROMINO_SHAPES);
                const randType = types[Math.floor(Math.random() * types.length)];
                return new Piece(randType);
            }

            // Dibuja la siguiente pieza en el área de "Siguiente"
            drawNextPiece() {
                nextPieceDisplay.innerHTML = ''; // Limpia el contenido anterior

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = 4 * BLOCK_SIZE; // Tamaño máximo para una pieza 4x4
                tempCanvas.height = 4 * BLOCK_SIZE;
                tempCanvas.style.display = 'inline-block';
                tempCanvas.style.verticalAlign = 'middle';
                tempCanvas.style.marginLeft = '10px';
                tempCanvas.style.backgroundColor = '#e0f4f8';
                tempCanvas.style.borderRadius = '8px';
                tempCanvas.style.border = '2px solid #a7d9f7';

                nextPiece.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value > 0) {
                            tempCtx.fillStyle = nextPiece.color;
                            tempCtx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            tempCtx.strokeStyle = '#fff';
                            tempCtx.lineWidth = 1;
                            tempCtx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    });
                });
                nextPieceDisplay.appendChild(tempCanvas);
            }
        }

        // --- Funciones de Juego ---
        function initBoard() {
            for (let r = 0; r < ROWS; r++) {
                board[r] = Array(COLS).fill('empty'); // Inicializa todas las celdas como vacías
            }
        }

        // Dibuja todo el tablero, incluyendo las piezas bloqueadas
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpia todo el canvas
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 'empty') {
                        ctx.fillStyle = board[r][c]; // Usa el color almacenado
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                }
            }
        }

        // Muestra un mensaje de combo en la pantalla
        function displayComboMessage(message) {
            comboMessageElement.textContent = message;
            comboMessageElement.classList.add('show');
            setTimeout(() => {
                comboMessageElement.classList.remove('show');
            }, 700); // El mensaje desaparece después de 0.7 segundos
        }

        // Mensajes para subir de nivel
        const levelUpMessages = [
            "¡Felicidades, eres imparable! Nuevo Nivel.",
            "¡Impresionante! ¡A por el siguiente reto!",
            "¡Subiste de nivel! Sigue así.",
            "¿Sabías que el Tetris fue creado en 1984? ¡Sigue haciendo historia!",
            "¡Guau! Tu concentración es de otro nivel. ¡Literalmente!",
            "El Tetris es como la vida, siempre buscando el encaje perfecto. ¡Vas genial!",
            "¿Qué hace un Tetris triste? ¡Se siente bloqueado! Pero tú no, ¡felicidades!",
            "¡Has alcanzado el siguiente nivel de la maestría en Tetris! ¡Adelante!",
            "Cada pieza es una oportunidad, y tú las aprovechas. ¡Nuevo nivel desbloqueado!",
            "¡Increíble! Sigue apilando éxitos y no solo bloques."
        ];

        // Muestra un mensaje de nivel en la pantalla
        function displayLevelUpMessage() {
            const randomIndex = Math.floor(Math.random() * levelUpMessages.length);
            levelUpMessageElement.textContent = levelUpMessages[randomIndex];
            levelUpMessageElement.classList.add('show');
            setTimeout(() => {
                levelUpMessageElement.classList.remove('show');
            }, 2000); // El mensaje de nivel dura más (2 segundos)
        }

        // Bucle principal del juego
        function gameLoop(currentTime) {
            gameLoopId = requestAnimationFrame(gameLoop); // Solicita el siguiente frame

            if (gameOver || isPaused) return; // Si está pausado o game over, no actualiza la lógica del juego

            if (currentTime - lastUpdateTime > currentFallInterval) { // Usa el intervalo de caída actual
                // La pieza cae si no colisiona
                if (!currentPiece.move(0, 1)) {
                    currentPiece.lock(); // Si colisiona, se bloquea
                }
                lastUpdateTime = currentTime;
            }

            drawBoard(); // Dibuja el tablero
            currentPiece.draw(); // Dibuja la pieza actual
        }

        // Inicia el juego
        function startGame() {
            initBoard();
            score = 0;
            level = 1;
            linesClearedTotal = 0; // Se mantiene, aunque el score es el principal para el nivel
            currentFallInterval = BASE_FALL_INTERVAL;
            nextLevelScoreThreshold = 2000; // Reinicia el umbral para el Nivel 1 -> 2
            isPaused = false; // Asegura que no esté pausado al inicio
            pauseButton.textContent = "Pausar"; // Restablece el texto del botón

            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            gameMessage.classList.add('hidden');
            comboMessageElement.classList.remove('show'); // Esconde mensajes de combo
            levelUpMessageElement.classList.remove('show'); // Esconde mensajes de nivel
            gameOver = false;
            currentPiece = new Piece(Object.keys(TETROMINO_SHAPES)[Math.floor(Math.random() * Object.keys(TETROMINO_SHAPES).length)]);
            nextPiece = new Piece(Object.keys(TETROMINO_SHAPES)[Math.floor(Math.random() * Object.keys(TETROMINO_SHAPES).length)]);
            currentPiece.drawNextPiece(); // Muestra la primera siguiente pieza
            lastUpdateTime = performance.now(); // Inicializa el tiempo
            if (gameLoopId) { // Asegura que no haya múltiples loops corriendo
                cancelAnimationFrame(gameLoopId);
            }
            gameLoopId = requestAnimationFrame(gameLoop); // Inicia el loop del juego
        }

        // --- Controles de Teclado ---
        document.addEventListener('keydown', e => {
            if (gameOver) {
                if (e.key === 'Enter') {
                    startGame(); // Reinicia el juego con Enter
                }
                return;
            }

            if (isPaused && e.key !== 'p' && e.key !== 'P') return; // No procesar teclas si está pausado, excepto 'p' para despausar

            switch (e.key) {
                case 'ArrowLeft':
                    currentPiece.move(-1, 0);
                    break;
                case 'ArrowRight':
                    currentPiece.move(1, 0);
                    break;
                case 'ArrowDown':
                    currentPiece.move(0, 1);
                    break;
                case 'ArrowUp':
                    currentPiece.rotate();
                    break;
                case ' ': // Espacio para soltar la pieza
                    while (currentPiece.move(0, 1)); // Mueve hacia abajo hasta que colisione
                    currentPiece.lock();
                    break;
                case 'p': // Tecla 'p' para pausa
                case 'P':
                    togglePause();
                    break;
            }
            if (!isPaused) { // Solo redibujar si no está pausado
                drawBoard(); // Redibuja el tablero y la pieza después del movimiento
                currentPiece.draw();
            }
        });

        // --- Controles Táctiles en el Canvas ---
        let touchStartX = 0;
        let touchStartY = 0;
        // Ajustes para hacer los controles más rápidos
        const tapThreshold = 10; // px para un "toque" (movimiento insignificante)
        const swipeThreshold = 30; // px mínimo para un "deslizamiento"
        const hardDropSwipeThreshold = 100; // px mínimo para un "deslizamiento fuerte hacia abajo" (hard drop)

        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); // Previene el scroll o zoom del navegador
            if (gameOver) {
                startGame(); // Reinicia el juego si está en Game Over
                return;
            }
            if (isPaused) return; // Ignora toques si está pausado

            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); // Previene el scroll o zoom del navegador
        });

        canvas.addEventListener('touchend', e => {
            if (gameOver || isPaused) return; // Si el juego terminó o está pausado, no procesar más toques de juego

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // Determinar si fue un deslizamiento o un toque
            const isTap = Math.abs(deltaX) < tapThreshold && Math.abs(deltaY) < tapThreshold;

            if (isTap) {
                // Es un toque: Rotar pieza
                currentPiece.rotate();
            } else {
                // Es un deslizamiento
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) {
                    // Deslizamiento horizontal
                    if (deltaX < 0) {
                        // Izquierda
                        currentPiece.move(-1, 0);
                    } else {
                        // Derecha
                        currentPiece.move(1, 0);
                    }
                } else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) {
                    // Deslizamiento vertical
                    if (deltaY > 0) {
                        // Abajo
                        if (Math.abs(deltaY) > hardDropSwipeThreshold) {
                            // Hard drop (caída instantánea)
                            while (currentPiece.move(0, 1));
                            currentPiece.lock();
                        } else {
                            // Soft drop (bajar una fila rápidamente)
                            currentPiece.move(0, 1);
                        }
                    }
                    // No hay acción para deslizar hacia arriba por ahora
                }
            }
            drawBoard(); // Redibuja el tablero y la pieza después del movimiento
            currentPiece.draw();
        });

        // --- Funciones de Pausa ---
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = "Reanudar";
                gameMessage.textContent = '¡Juego Pausado!';
                gameMessage.classList.remove('hidden');
            } else {
                pauseButton.textContent = "Pausar";
                gameMessage.classList.add('hidden');
                lastUpdateTime = performance.now(); // Resetea el tiempo para evitar caída instantánea al reanudar
                gameLoop(performance.now()); // Reanuda el bucle del juego
            }
        }
        // Event Listener para el botón de pausa
        pauseButton.addEventListener('click', togglePause);


        // Reinicia el juego si está en Game Over y se hace clic en cualquier parte (excepto el botón de pausa)
        document.addEventListener('click', (e) => {
            if (gameOver && e.target !== canvas && e.target !== pauseButton) { // Excluye el canvas y el botón de pausa
                startGame();
            }
        });


        // Asegura que el juego se inicie una vez el DOM esté completamente cargado
        window.onload = function() {
            startGame();
        };
    </script>
</body>
</html>
