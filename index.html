<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Pastel Intenso</title>
    <style>
        /* Estilo personalizado para el canvas del juego */
        canvas {
            background-color: #e0e7ee; /* Un gris azulado muy claro para un mejor contraste con colores intensos */
            border: 4px solid #7cb9e8; /* Borde azul vibrante */
            border-radius: 12px; /* Esquinas redondeadas para el canvas */
            display: block;
            margin: 0 auto;
            touch-action: none; /* MUY IMPORTANTE: Previene el desplazamiento por defecto en móviles */
        }

        /* Estilo general para el cuerpo de la página */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #a7d9f7 0%, #b2e6b2 100%); /* Degradado suave pero más vivo */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #2d3748; /* Color de texto más oscuro para legibilidad */
        }

        /* Contenedor principal del juego */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; /* Fondo blanco para el contenedor */
            border-radius: 20px; /* Esquinas más redondeadas */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); /* Sombra más pronunciada */
            padding: 25px;
            gap: 20px; /* Espacio entre elementos */
            position: relative; /* Para posicionar los mensajes */
        }

        /* Estilo para el mensaje de combo */
        #combo-message, #level-up-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.2em; /* Un poco más grande */
            font-weight: bold;
            color: #ef4444; /* Rojo vibrante */
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.4); /* Sombra más fuerte */
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none; /* Permite clics a través del mensaje */
            text-align: center; /* Centra el texto */
        }

        #level-up-message {
            color: #10B981; /* Verde más intenso para mensajes de nivel */
            font-size: 2em; /* Ajustado para ser más pequeño y legible */
        }

        #combo-message.show, #level-up-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15); /* Efecto de escala más pronunciado */
        }

        /* Estilo para los botones de control (Pausa, Inicio/Reiniciar) */
        .game-button {
            background-color: #FFC107; /* Amarillo pastel por defecto */
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            transform: scale(1);
            border: none;
            cursor: pointer;
            margin-top: 10px; /* Espacio superior */
        }

        .game-button.start-button {
            background-color: #10B981; /* Verde más intenso para iniciar/reiniciar */
        }

        .game-button.pause-button {
            background-color: #F59E0B; /* Naranja más intenso para pausa */
        }

        .game-button:hover {
            transform: scale(1.05);
        }

        .game-button.start-button:hover {
            background-color: #059669; /* Verde más oscuro al pasar el ratón */
        }
        .game-button.pause-button:hover {
            background-color: #D97706; /* Naranja más oscuro al pasar el ratón */
        }

        .game-button:active {
            transform: scale(0.98);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Adaptabilidad para pantallas pequeñas */
        @media (max-width: 640px) {
            .game-container {
                padding: 15px;
                gap: 15px;
            }
            #combo-message {
                font-size: 2.5em;
            }
            #level-up-message {
                font-size: 1.5em; /* Ajustado para pantallas pequeñas */
            }
            .game-button {
                padding: 0.6rem 1.2rem;
                font-size: 1em;
            }
        }
    </style>
</head>
<body class="selection:bg-pink-200 selection:text-pink-800">
    <div class="game-container">
        <h1 class="text-4xl md:text-5xl font-extrabold text-blue-600 mb-4 text-center">Tetris Pastel Intenso</h1>
        <div id="game-info" class="text-lg font-semibold text-gray-700 mb-3 text-center">
            Puntuación: <span id="score">0</span> | Nivel: <span id="level">1</span> | Siguiente: <span id="next-piece-display"></span>
        </div>
        <canvas id="tetrisCanvas"></canvas>
        <div id="game-message" class="text-2xl font-bold text-red-500 mt-4"></div>
        <div id="combo-message"></div> <!-- Mensaje de combo -->
        <div id="level-up-message"></div> <!-- Mensaje de subir de nivel -->

        <!-- Botones de control -->
        <div class="flex gap-4 mt-2">
            <button id="startButton" class="game-button start-button">Iniciar Juego</button>
            <button id="pauseButton" class="game-button pause-button hidden">Pausar</button>
        </div>

        <!-- Los controles táctiles ahora se implementan directamente en el canvas -->
    </div>

    <script>
        // --- Configuración del Canvas ---
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');

        const COLS = 10; // Columnas del tablero
        const ROWS = 20; // Filas del tablero
        const BLOCK_SIZE = 35; // Tamaño de cada bloque en píxeles

        // Ajusta el tamaño del canvas
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        // --- Definición de Múltiples Paletas de Colores ---
        const COLOR_PALETTES = [
            // Palette 0: Original Intenso
            [
                '#FF69B4', // Rosa Fuerte (Hot Pink) - I
                '#FFD700', // Oro (Gold) - O
                '#00BFFF', // Azul Cielo Profundo (Deep Sky Blue) - T
                '#32CD32', // Verde Lima (Lime Green) - S
                '#FF4500', // Naranja Rojo (Orange Red) - Z
                '#4169E1', // Azul Real (Royal Blue) - J
                '#9932CC'  // Púrpura (Dark Orchid) - L
            ],
            // Palette 1: Neón / Brillante
            [
                '#FF00FF', // Magenta - I
                '#FFFF00', // Amarillo Puro - O
                '#00FFFF', // Cian - T
                '#00FF00', // Verde Brillante - S
                '#FF0000', // Rojo Brillante - Z
                '#0000FF', // Azul Brillante - J
                '#8A2BE2'  // Azul Violeta - L
            ],
            // Palette 2: Naturaleza / Tierra
            [
                '#9ACD32', // Verde Amarillo - I
                '#DAA520', // Oro Viejo - O
                '#6B8E23', // Verde Oliva - T
                '#5F9EA0', // Azul Cadete - S
                '#D2691E', // Chocolate - Z
                '#8B4513', // Marrón Silla - J
                '#A0522D'  // Sienna - L
            ],
            // Palette 3: Oscuro / Galáctico
            [
                '#4B0082', // Indigo - I
                '#1E90FF', // Azul Dodger - O
                '#BA55D3', // Orquídea Media - T
                '#20B2AA', // Azul Verde Claro - S
                '#FF1493', // Rosa Profundo - Z
                '#7B68EE', // Azul Pizarra Medio - J
                '#4682B4'  // Acero Azul - L
            ],
            // Puedes añadir más paletas aquí para niveles más altos
            [
                '#F08080', // Coral Claro
                '#ADD8E6', // Azul Claro
                '#90EE90', // Verde Claro
                '#FFB6C1', // Rosa Claro
                '#DDA0DD', // Ciruela
                '#87CEEB', // Azul Cielo Claro
                '#FFDAB9'  // Melocotón
            ]
        ];

        // Se inicializa la paleta de colores actual
        let COLORS = COLOR_PALETTES[0];

        // --- Variables del Juego ---
        let board = []; // El tablero de juego
        let currentPiece; // La pieza actual en juego
        let nextPiece; // La siguiente pieza
        let score = 0; // Puntuación del jugador
        let gameOver = false; // Estado del juego
        let gameLoopId; // ID para el loop del juego (para clearInterval)
        let lastUpdateTime = 0; // Para controlar el tiempo de caída de la pieza

        let level = 1; // Nivel actual del juego
        let linesClearedTotal = 0; // Total de líneas limpiadas en el juego (se mantiene para estadísticas, pero el score define el nivel)
        const BASE_FALL_INTERVAL = 600; // Intervalo de caída base en ms (un poco más lento para empezar)
        let currentFallInterval = BASE_FALL_INTERVAL; // Intervalo de caída actual
        let nextLevelScoreThreshold = 500; // Puntos necesarios para el siguiente nivel (Nivel 1 a 2)
        let isPaused = false; // Variable para controlar el estado de pausa
        let gameStarted = false; // Variable para controlar si el juego ha iniciado

        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const gameMessage = document.getElementById('game-message');
        const nextPieceDisplay = document.getElementById('next-piece-display');
        const comboMessageElement = document.getElementById('combo-message');
        const levelUpMessageElement = document.getElementById('level-up-message'); // Nuevo elemento para mensajes de nivel
        const startButton = document.getElementById('startButton'); // Referencia al nuevo botón de inicio
        const pauseButton = document.getElementById('pauseButton');

        // --- Definición de Piezas (Tetrominoes) ---
        // Cada pieza es un array de matrices, representando sus rotaciones.
        // Los números indican el color/tipo de la pieza (índice en COLORS).
        const TETROMINO_SHAPES = {
            'I': { shape: [[1, 1, 1, 1]], colorIndex: 0 },
            'O': { shape: [[1, 1], [1, 1]], colorIndex: 1 },
            'T': { shape: [[0, 1, 0], [1, 1, 1]], colorIndex: 2 },
            'S': { shape: [[0, 1, 1], [1, 1, 0]], colorIndex: 3 },
            'Z': { shape: [[1, 1, 0], [0, 1, 1]], colorIndex: 4 },
            'J': { shape: [[1, 0, 0], [1, 1, 1]], colorIndex: 5 },
            'L': { shape: [[0, 0, 1], [1, 1, 1]], colorIndex: 6 }
        };

        // Class para representar una pieza de Tetris
        class Piece {
            constructor(shapeType) {
                const { shape, colorIndex } = TETROMINO_SHAPES[shapeType];
                this.shape = shape;
                this.color = COLORS[colorIndex]; // Ahora COLORS es dinámico
                this.x = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2); // Posición inicial X
                this.y = 0; // Posición inicial Y
                this.shapeType = shapeType; // Guarda el tipo de forma (para mostrar la siguiente)
            }

            // Dibuja la pieza en el canvas
            draw() {
                this.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value > 0) {
                            ctx.fillStyle = this.color;
                            ctx.fillRect(this.x * BLOCK_SIZE + c * BLOCK_SIZE, this.y * BLOCK_SIZE + r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            ctx.strokeStyle = '#fff'; // Borde blanco suave para los bloques
                            ctx.lineWidth = 1;
                            ctx.strokeRect(this.x * BLOCK_SIZE + c * BLOCK_SIZE, this.y * BLOCK_SIZE + r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    });
                });
            }

            // Mueve la pieza
            move(dx, dy) {
                if (!this.collision(dx, dy, this.shape)) {
                    this.x += dx;
                    this.y += dy;
                    return true;
                }
                return false;
            }

            // Rota la pieza
            rotate() {
                // Función para transponer una matriz (filas a columnas)
                const transpose = (matrix) => matrix[0].map((_, i) => matrix.map(row => row[i]));
                // Función para invertir las filas de una matriz (para rotación anti-horaria)
                const reverseRows = (matrix) => matrix.map(row => [...row].reverse());

                let rotatedShape = transpose(this.shape);
                // Si es la pieza 'I' o 'S' o 'Z', rota de forma diferente para mantener la forma
                if (this.shapeType === 'I' || this.shapeType === 'S' || this.shapeType === 'Z') {
                    rotatedShape = reverseRows(rotatedShape);
                } else {
                    rotatedShape = rotatedShape.reverse(); // Rotación normal para otras piezas
                }

                if (!this.collision(0, 0, rotatedShape)) {
                    this.shape = rotatedShape;
                    return true;
                }
                // Si la rotación causa colisión, intenta desplazar la pieza (Wall Kick)
                const kicks = [
                    [0, 0], [-1, 0], [1, 0], [0, -1], [-1, -1], [1, -1]
                ]; // Posibles desplazamientos para wall kick

                for (let i = 0; i < kicks.length; i++) {
                    const [dx, dy] = kicks[i];
                    if (!this.collision(dx, dy, rotatedShape)) {
                        this.x += dx;
                        this.y += dy;
                        this.shape = rotatedShape;
                        return true;
                    }
                }
                return false;
            }

            // Comprueba si hay colisión en una posición dada con una forma específica
            collision(dx, dy, newShape) {
                for (let r = 0; r < newShape.length; r++) {
                    for (let c = 0; c < newShape[r].length; c++) {
                        if (newShape[r][c] > 0) { // Si es un bloque de la pieza
                            let newX = this.x + c + dx;
                            let newY = this.y + r + dy;

                            // Comprueba los límites del tablero y las colisiones con bloques existentes
                            if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 'empty')) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Bloquea la pieza en el tablero
            lock() {
                this.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value > 0) {
                            let boardX = this.x + c;
                            let boardY = this.y + r;
                            if (boardY < 0) { // Si la pieza está por encima del tablero (game over)
                                gameOver = true;
                                gameMessage.textContent = '¡Game Over!';
                                gameMessage.classList.remove('hidden'); // Asegura que el mensaje de Game Over sea visible
                                startButton.textContent = "Reiniciar Juego"; // Cambia el texto del botón
                                startButton.classList.remove('hidden'); // Asegura que el botón sea visible
                                pauseButton.classList.add('hidden'); // Oculta el botón de pausa
                                clearInterval(gameLoopId); // Detiene el bucle del juego
                                return;
                            }
                            board[boardY][boardX] = this.color; // Asigna el color al tablero
                        }
                    });
                });
                this.clearLines(); // Comprueba y limpia líneas
                this.generateNewPiece(); // Genera una nueva pieza
            }
            // Elimina líneas completas del tablero
            clearLines() {
                let linesCleared = 0;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r].every(cell => cell !== 'empty')) { // Si la fila está completa
                        linesCleared++;
                        // Elimina la fila y añade una nueva fila vacía al principio
                        board.splice(r, 1);
                        board.unshift(Array(COLS).fill('empty'));
                        r++; // Vuelve a verificar la misma fila (ahora con los bloques de arriba)
                    }
                }
                if (linesCleared > 0) {
                    score += linesCleared * 100 * level; // Aumenta la puntuación, influenciada por el nivel
                    scoreDisplay.textContent = score;

                    linesClearedTotal += linesCleared; // Actualiza el total de líneas limpiadas

                    // Verifica si se sube de nivel basado en la puntuación
                    if (level < 10 && score >= nextLevelScoreThreshold) { // Máximo 10 niveles
                        level++;
                        levelDisplay.textContent = level;
                        // Recalcula el umbral de puntos para el siguiente nivel
                        // Nivel 1 a 2: 500, Nivel 2 a 3: 500 + 1000 = 1500, Nivel 3 a 4: 1500 + 1000 = 2500
                        nextLevelScoreThreshold += 1000; // Incrementa el umbral en 1000 para el siguiente nivel

                        // Reduce el intervalo de caída para aumentar la velocidad (dificultad)
                        currentFallInterval = Math.max(50, BASE_FALL_INTERVAL - (level * 75)); // Aumenta la velocidad más rápido

                        // Pausar el juego, limpiar el tablero y mostrar el chiste
                        isPaused = true;
                        pauseButton.textContent = "Reanudar"; // Actualiza el texto del botón de pausa
                        cancelAnimationFrame(gameLoopId); // Detiene el bucle del juego

                        initBoard(); // Limpia el tablero al pasar de nivel
                        drawBoard(); // Dibuja el tablero vacío después de limpiar
                        COLORS = COLOR_PALETTES[(level -1) % COLOR_PALETTES.length]; // Cambia la paleta de colores
                        
                        displayLevelUpMessage(); // Muestra el mensaje de nivel (chiste)
                    }

                    // Efectos especiales para combos
                    if (linesCleared === 2) {
                        displayComboMessage('¡Doble!');
                    } else if (linesCleared === 3) {
                        displayComboMessage('¡Triple!');
                    } else if (linesCleared === 4) {
                        displayComboMessage('¡Tetris!');
                    }
                }
            }

            // Genera una nueva pieza para el juego
            generateNewPiece() {
                currentPiece = nextPiece;
                nextPiece = this.randomPiece();
                this.drawNextPiece();
                if (currentPiece.collision(0, 0, currentPiece.shape)) { // Si la nueva pieza colisiona al inicio
                    gameOver = true;
                    gameMessage.textContent = '¡Game Over!';
                    gameMessage.classList.remove('hidden'); // Asegura que el mensaje de Game Over sea visible
                    startButton.textContent = "Reiniciar Juego"; // Cambia el texto del botón
                    startButton.classList.remove('hidden'); // Asegura que el botón sea visible
                    pauseButton.classList.add('hidden'); // Oculta el botón de pausa
                    clearInterval(gameLoopId);
                }
            }

            // Devuelve una pieza aleatoria
            randomPiece() {
                const types = Object.keys(TETROMINO_SHAPES);
                const randType = types[Math.floor(Math.random() * types.length)];
                return new Piece(randType);
            }

            // Dibuja la siguiente pieza en el área de "Siguiente"
            drawNextPiece() {
                nextPieceDisplay.innerHTML = ''; // Limpia el contenido anterior

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = 4 * BLOCK_SIZE; // Tamaño máximo para una pieza 4x4
                tempCanvas.height = 4 * BLOCK_SIZE;
                tempCanvas.style.display = 'inline-block';
                tempCanvas.style.verticalAlign = 'middle';
                tempCanvas.style.marginLeft = '10px';
                tempCanvas.style.backgroundColor = '#e0f4f8';
                tempCanvas.style.borderRadius = '8px';
                tempCanvas.style.border = '2px solid #a7d9f7';

                nextPiece.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value > 0) {
                            tempCtx.fillStyle = nextPiece.color;
                            tempCtx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            tempCtx.strokeStyle = '#fff';
                            tempCtx.lineWidth = 1;
                            tempCtx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    });
                });
                nextPieceDisplay.appendChild(tempCanvas);
            }
        }

        // --- Funciones de Juego ---
        function initBoard() {
            for (let r = 0; r < ROWS; r++) {
                board[r] = Array(COLS).fill('empty'); // Inicializa todas las celdas como vacías
            }
        }

        // Dibuja todo el tablero, incluyendo las piezas bloqueadas
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpia todo el canvas
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 'empty') {
                        ctx.fillStyle = board[r][c]; // Usa el color almacenado
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                }
            }
        }

        // Muestra un mensaje de combo en la pantalla
        function displayComboMessage(message) {
            comboMessageElement.textContent = message;
            comboMessageElement.classList.add('show');
            setTimeout(() => {
                comboMessageElement.classList.remove('show');
            }, 700); // El mensaje desaparece después de 0.7 segundos
        }

        // Chistes para subir de nivel (NUEVOS CHISTES AÑADIDOS AQUÍ)
        const levelUpJokes = [
            "¿Qué le dice un Tetris a otro? ¡Deja de apilarte, que me ahogo!",
            "¿Por qué el Tetris nunca gana en un debate? ¡Siempre se queda bloqueado!",
            "Un Tetris entra a un bar... y le dicen: 'Lo siento, aquí no se permiten piezas sueltas'.",
            "¿Cuál es el colmo de un Tetris? ¡Que se le caigan todas las líneas!",
            "Mi vida es como un Tetris: si todo encaja, desaparece.",
            "¿Qué hace un Tetris en el gimnasio? ¡Forma cubos!",
            "¿Por qué los Tetris son buenos en matemáticas? ¡Porque siempre están calculando ángulos!",
            "Mi psicólogo me dijo que mi ansiedad se debía a un juego de Tetris mal resuelto en mi pasado.",
            "¿Qué es un Tetris bailando? ¡Un baile de bloques!",
            "¡Felicidades! Has superado otro nivel, ahora el juego se pone más... en línea.",
            "¿Por qué el lápiz se deprimió? Porque estaba muy atilado.",
            "¿Qué le dice una pared a otra pared? ¡Nos vemos en la esquina!",
            "¿Qué hace una computadora en la playa? Busca un mouse playero.",
            "¿Cómo se llama el hermano mayor de un tomate? ¡Tomatón!",
            "¿Por qué el perro no puede jugar a las cartas? Porque siempre se sienta sobre las barajas."
        ];

        // Muestra un chiste de nivel en la pantalla
        function displayLevelUpMessage() {
            const randomIndex = Math.floor(Math.random() * levelUpJokes.length);
            levelUpMessageElement.innerHTML = `¡Nivel ${level}! <br>` + levelUpJokes[randomIndex]; // Añade salto de línea para chiste
            levelUpMessageElement.classList.add('show');
            // El chiste se quedará en pantalla hasta que se reanude el juego.
            // El setTimeout solo es para que se quite si el juego no estuviera pausado (escenario improbable aquí).
            setTimeout(() => {
                //levelUpMessageElement.classList.remove('show'); // No ocultar automáticamente si el juego está pausado por nivel
            }, 30000); // El chiste dura al menos 30 segundos si el usuario no reanuda antes
        }

        // Bucle principal del juego
        function gameLoop(currentTime) {
            gameLoopId = requestAnimationFrame(gameLoop); // Solicita el siguiente frame

            if (gameOver || isPaused || !gameStarted) return; // Si está pausado, game over, o no ha iniciado, no actualiza

            if (currentTime - lastUpdateTime > currentFallInterval) { // Usa el intervalo de caída actual
                // La pieza cae si no colisiona
                if (!currentPiece.move(0, 1)) {
                    currentPiece.lock(); // Si colisiona, se bloquea
                }
                lastUpdateTime = currentTime;
            }

            drawBoard(); // Dibuja el tablero
            currentPiece.draw(); // Dibuja la pieza actual
        }

        // Inicia el juego
        function startGame() {
            initBoard();
            score = 0;
            level = 1;
            linesClearedTotal = 0;
            currentFallInterval = BASE_FALL_INTERVAL;
            nextLevelScoreThreshold = 500; // Reinicia el umbral para el Nivel 1 -> 2
            isPaused = false;
            gameOver = false;
            gameStarted = true; // El juego ha iniciado

            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            gameMessage.classList.add('hidden'); // Oculta el mensaje de inicio/game over
            comboMessageElement.classList.remove('show'); // Esconde mensajes de combo
            levelUpMessageElement.classList.remove('show'); // Esconde mensajes de nivel

            // Oculta el botón de inicio y muestra el de pausa
            startButton.classList.add('hidden');
            pauseButton.classList.remove('hidden');
            pauseButton.textContent = "Pausar"; // Restablece el texto del botón

            // Asigna la paleta de colores inicial para el nivel 1
            COLORS = COLOR_PALETTES[0];

            currentPiece = new Piece(Object.keys(TETROMINO_SHAPES)[Math.floor(Math.random() * Object.keys(TETROMINO_SHAPES).length)]);
            nextPiece = new Piece(Object.keys(TETROMINO_SHAPES)[Math.floor(Math.random() * Object.keys(TETROMINO_SHAPES).length)]);
            currentPiece.drawNextPiece();
            lastUpdateTime = performance.now();
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- Controles de Teclado ---
        document.addEventListener('keydown', e => {
            if (!gameStarted) return; // No procesar teclas si el juego no ha iniciado

            if (gameOver) {
                if (e.key === 'Enter') {
                    startGame(); // Reinicia el juego con Enter
                }
                return;
            }

            if (isPaused && e.key !== 'p' && e.key !== 'P') return;

            switch (e.key) {
                case 'ArrowLeft':
                    currentPiece.move(-1, 0);
                    break;
                case 'ArrowRight':
                    currentPiece.move(1, 0);
                    break;
                case 'ArrowDown':
                    currentPiece.move(0, 1);
                    break;
                case 'ArrowUp':
                    currentPiece.rotate();
                    break;
                case ' ': // Espacio para soltar la pieza
                    while (currentPiece.move(0, 1));
                    currentPiece.lock();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
            if (!isPaused) {
                drawBoard();
                currentPiece.draw();
            }
        });

        // --- Controles Táctiles en el Canvas ---
        let touchStartX = 0;
        let touchStartY = 0;
        const tapThreshold = 10; // Reducido para mayor sensibilidad al toque
        const swipeThreshold = 25; // Reducido para mayor sensibilidad al deslizamiento
        const hardDropSwipeThreshold = 90; // Reducido para hacer el hard drop más fácil de activar

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (!gameStarted) { // Si el juego no ha iniciado, un toque en el canvas no hace nada (se usa el botón de inicio)
                return;
            }
            if (gameOver) { // Si el juego ha terminado, presionar el canvas (que no sea el botón) no hace nada
                return;
            }
            if (isPaused) return;

            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
        });

        canvas.addEventListener('touchend', e => {
            if (!gameStarted || gameOver || isPaused) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            const isTap = Math.abs(deltaX) < tapThreshold && Math.abs(deltaY) < tapThreshold;

            if (isTap) {
                currentPiece.rotate();
            } else {
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > swipeThreshold) {
                    if (deltaX < 0) {
                        currentPiece.move(-1, 0);
                    } else {
                        currentPiece.move(1, 0);
                    }
                } else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > swipeThreshold) {
                    if (deltaY > 0) {
                        if (Math.abs(deltaY) > hardDropSwipeThreshold) {
                            while (currentPiece.move(0, 1));
                            currentPiece.lock();
                        } else {
                            currentPiece.move(0, 1);
                        }
                    }
                }
            }
            drawBoard();
            currentPiece.draw();
        });

        // --- Funciones de Pausa ---
        function togglePause() {
            if (!gameStarted || gameOver) return; // No permitir pausa si el juego no ha iniciado o ya terminó

            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = "Reanudar";
                gameMessage.textContent = '¡Juego Pausado!';
                gameMessage.classList.remove('hidden'); // Muestra el mensaje de "Juego Pausado!"
                cancelAnimationFrame(gameLoopId); // Detener el bucle de animación cuando está pausado
            } else {
                pauseButton.textContent = "Pausar";
                gameMessage.classList.add('hidden'); // Oculta el mensaje de "Juego Pausado!"
                levelUpMessageElement.classList.remove('show'); // Oculta el chiste al reanudar
                lastUpdateTime = performance.now();
                gameLoop(performance.now()); // Reanudar el bucle de animación
            }
        }
        // Event Listener para el botón de pausa
        pauseButton.addEventListener('click', togglePause);

        // --- Funciones de Inicio de Juego ---
        startButton.addEventListener('click', () => {
            if (gameOver) {
                // Si el juego terminó, reiniciar
                startGame();
            } else if (!gameStarted) {
                // Si el juego aún no ha iniciado, iniciar por primera vez
                startGame();
            } else if (isPaused) {
                // Si el juego está pausado, reanudar
                togglePause();
            }
        });

        // --- Inicialización al cargar la ventana ---
        window.onload = function() {
            initBoard(); // Inicializa el tablero
            drawBoard(); // Dibuja el tablero vacío
            gameMessage.textContent = 'Pulsa "Iniciar Juego" para jugar';
            gameMessage.classList.remove('hidden'); // Muestra el mensaje de inicio
            startButton.textContent = "Iniciar Juego";
            startButton.classList.remove('hidden'); // Asegura que el botón de inicio sea visible
            pauseButton.classList.add('hidden'); // Asegura que el botón de pausa esté oculto al inicio

            // No iniciar gameLoop aquí, se iniciará con el botón
        };
    </script>
</body>
</html>
